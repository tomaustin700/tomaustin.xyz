---
id: 427
title: Deploying an API to Azure Kubernetes Service (AKS) using Azure DevOps
date: 2019-05-26T13:59:21+01:00
author: tom
layout: post
guid: http://3.10.198.211/?p=427
permalink: /2019/05/26/deploying-an-api-to-azure-kubernetes-service-aks-using-azure-devops/
image: /wp-content/uploads/2019/05/image-49.png
categories:
  - asp.net
  - azure
  - kubernetes
tags:
  - api
  - azure kubernetes service
---
This article is the second in a series exploring [AKS](https://azure.microsoft.com/en-gb/services/kubernetes-service/) and how to leverage [Azure DevOps](https://azure.microsoft.com/en-us/services/devops/) to easily deploy and update services running inside AKS. The first article in the series can be found [here](http://tomaustin.xyz/2019/05/18/deploying-a-website-to-azure-kubernetes-service-aks-using-azure-devops/) and guided you through deploying a simple website to AKS, this article will show you how to do the same but with an API.

I&#8217;m going to assume you already have a Kubernetes cluster running in Azure and you are already familiar with Azure DevOps pipelines, if not then please go back and read the first article which covers these steps in detail. 

Let&#8217;s start by opening Visual Studio and creating a new ASP.Net Core Web Application using the built in template.<figure class="wp-block-image is-resized">

<img loading="lazy" src="http://tomaustin.xyz/wp-content/uploads/2019/05/image-20.png" alt="" class="wp-image-369" width="512" height="255" srcset="https://tomaustin.xyz/wp-content/uploads/2019/05/image-20.png 615w, https://tomaustin.xyz/wp-content/uploads/2019/05/image-20-300x150.png 300w" sizes="(max-width: 512px) 100vw, 512px" /> </figure> 

When prompted we are going to select API, make sure that &#8216;Enable Docker Support&#8217; is ticked and the mode is set to &#8216;Linux&#8217;. I&#8217;m going to leave Authentication set to &#8216;No Authentication&#8217; as this is just going to be a very basic API for the purposes of this tutorial.<figure class="wp-block-image">

<img loading="lazy" width="735" height="171" src="http://tomaustin.xyz/wp-content/uploads/2019/05/image-49.png" alt="" class="wp-image-430" srcset="https://tomaustin.xyz/wp-content/uploads/2019/05/image-49.png 735w, https://tomaustin.xyz/wp-content/uploads/2019/05/image-49-300x70.png 300w, https://tomaustin.xyz/wp-content/uploads/2019/05/image-49-720x168.png 720w" sizes="(max-width: 735px) 100vw, 735px" /> </figure> 

Once created we should have a very basic API with a basic controller (ValuesController). Let&#8217;s right click on the project and add &#8216;Container Orchestrator Support&#8217;, make sure &#8216;Kubernetes/Helm&#8217; is selected.

<div class="wp-block-image">
  <figure class="aligncenter is-resized"><img loading="lazy" src="http://tomaustin.xyz/wp-content/uploads/2019/05/image-22.png" alt="" class="wp-image-372" width="400" height="414" srcset="https://tomaustin.xyz/wp-content/uploads/2019/05/image-22.png 602w, https://tomaustin.xyz/wp-content/uploads/2019/05/image-22-290x300.png 290w" sizes="(max-width: 400px) 100vw, 400px" /></figure>
</div>

So far this is identical to the process of adding a website, we&#8217;re even going to configure our helm files to be the same. The files generated by Visual Studio are a good starting point but I&#8217;d recommend using the basic yaml files I have put together (values.yaml can be found [here](https://gist.github.com/tomaustin700/d75cb6b3746a160b8570886e54b97333) and ingress.yaml [here](https://gist.github.com/tomaustin700/66544ccc002b7c2a2b314b9309180b41) &#8211; remember to replace website/kuberwebsite with your API&#8217;s name), for deployment.yaml things are slightly different.

Deployment.yaml contains definitions for two probes (readiness and liveness) which are used by Kubernetes to detect if everything is working correctly and if not trigger a restart of the container. We need to point these to our controller, if not Kubernetes will not get a response and the API will constantly be restarted. Update the probes to look like this:

<pre class="wp-block-code"><code>livenessProbe:
            httpGet:
              path: /api/values
              port: http
          readinessProbe:
            httpGet:
              path: /api/values
              port: http</code></pre>

If you are doing this for real I&#8217;d recommend creating a &#8216;health&#8217; controller which is dedicated to informing Kubernetes that everything is okay. The full copy of my deployment.yaml file can be found [here](https://gist.github.com/tomaustin700/c5ae694a0065b2b0732bdf1437c35280) (I&#8217;ve also declared some environment variables for Application Insights but you don&#8217;t need those). 

Once done push your code to Azure DevOps like we did in the previous tutorial and construct your pipelines identically (I&#8217;d even recommend just cloning the pipelines we made before and changing the repo and the environment variables). That should be it!

We have been using HTTP application routing provided by Azure to access our website/api but the next tutorial will focus on deploying our our [NGINX](https://www.nginx.com/) Ingress controller which will leverage [Let&#8217;s Encrypt](https://letsencrypt.org/) for HTTPS &#8211; this will all be declared in code and deployed using Azure DevOps (of course!).